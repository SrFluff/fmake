#!/bin/python3
version = "1.5.2"
import os
import libfmake
import sys
sys.argv.pop(0)

vals = ("gcc","main.c","main",True,"Compiling done!",False,False,"-j$(nproc)")

cc = vals[0]
src = vals[1]
out = vals[2]
msg = vals[3]
say = vals[4]
run = vals[5]
mke = vals[6]
mkf = vals[7]

def comp():
    
    cc = vals[0]
    src = vals[1]
    out = vals[2]
    msg = vals[3]
    say = vals[4]
    run = vals[5]
    mke = vals[6]
    mkf = vals[7]

    if not mke:
        os.system(f"{cc} -o {out} {src}")
    else:
        os.system(f"make {mkf}")
    if msg:
        print(say)

def debug():
    cc = vals[0]
    src = vals[1]
    out = vals[2]
    msg = vals[3]
    say = vals[4]
    run = vals[5]
    mke = vals[6]
    mkf = vals[7]

    print(f"CC:\t{cc}")
    print(f"SRC:\t{src}")
    print(f"OUT:\t{out}")
    print(f"MSG:\t{msg}")
    print(f"SAY:\t{say}")
    print(f"RUN:\t{run}")
    print(f"MKE:\t{mke}")
    print(f"MKF:\t{mkf}")

def clean():
    cc = vals[0]
    src = vals[1]
    out = vals[2]
    msg = vals[3]
    say = vals[4]
    run = vals[5]
    mke = vals[6]
    mkf = vals[7]

    if os.path.exists(out):
        os.remove(out)

if len(sys.argv) == 0:
    vals = libfmake.readConfig("make.fmake")
elif len(sys.argv) == 1:
    if os.path.exists("make.fmake"):
        libfmake.readConfig("make.fmake")
    else:
        print("[ERROR] No 'make.fmake' file.")
        sys.exit()
    match sys.argv[0]:
        case "debug":
            debug()
        case "clean":
            clean()
        case "version":
            print(version)
        case "project":
            if not os.path.exists("src/"):
                os.mkdir("src")
            if not os.path.exists("build/"):
                os.mkdir("build")
            if not os.path.exists("src/main.c"):
                f = open("src/main.c","w")
                f.write("#include <stdio.h>\n\nint main(void) {\n\treturn 0;\n}\n")
                f.close()
            if not os.path.exists("make.fmake"):
                f = open("make.fmake","w")
                f.write("cc $\nsrc = src/main.c\nout = build/main\nmsg $\nsay $\nrun = true\nmke = false\nmkf $\n")
                f.close()
        case "example":
            f = open("make.fmake","w")
            f.write("cc = gcc\nsrc = main.c\nout = main\nmsg = true\nsay = Compiling done!\nrun = false\nmkf = -j$(nproc)\n")
            f.close()
        case "help" | "--help" | "-h" | "-?":
            print("Usage: fmake [keyword] [rule]")
            print()
            print("Keywords:")
            print("rule    - Compiles a specific rule. To make a rule just make a <rule>.fmake file.")
            print("clean   - Removes the compiled executable.")
            print("debug   - Prints all the values of specific rule.")
            print("example - Generates an example make.fmake file.")
            print("project - Makes a build/ & src/ directory along with a custom make.fmake file.")
            print("version - Returns the current version of fmake.")
            print()
            print("Note: Example, project, and version require no rule.")
            print("Note: If no rule is passed to rule, clean, or debug it will default to make.fmake, if it exists.")

elif len(sys.argv) > 1:
    if sys.argv[0] == "rule":
        if os.path.exists(sys.argv[1] + ".fmake"):
            vals = libfmake.readConfig(sys.argv[1] + ".fmake")
            comp()
        else:
            print("[ERROR] No such rule exists.")
            sys.exit()
    elif sys.argv[0] == "debug":
        if os.path.exists(sys.argv[1] + ".fmake"):
            vals = libfmake.readConfig(sys.argv[1] + ".fmake")
            debug()
        else:
            print("[ERROR] No such rule exists.")
    elif sys.argv[0] == "clean":
        if os.path.exists(sys.argv[1] + ".fmake"):
            vals = libfmake.readConfig(sys.argv[1] + ".fmake")
            clean()
        else:
            print("[ERROR] No such rule exists.")
